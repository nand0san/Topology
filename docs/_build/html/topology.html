<!DOCTYPE html>
<html lang="en" data-accent-color="violet" data-content_root="./">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Topology - Topology documentation</title><link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="Functions Module" href="functions.html" /><link rel="prev" title="Welcome to Topology’s documentation!" href="index.html" /><script>
    function setColorMode(t){let e=document.documentElement;e.setAttribute("data-color-mode",t);let a=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,s=t;"auto"===t&&(s=a?"dark":"light"),"light"===s?(e.classList.remove("dark"),e.classList.add("light")):(e.classList.remove("light"),e.classList.add("dark"))}
    setColorMode(localStorage._theme||"auto");
  </script><link rel="stylesheet" type="text/css" href="_static/pygments.css?v=397bb51e" />
    <link rel="stylesheet" type="text/css" href="_static/shibuya.css?v=36d120a7" />
    <link media="print" rel="stylesheet" type="text/css" href="_static/print.css?v=20ff2c19" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --sy-f-text: "Inter", var(--sy-f-sys), var(--sy-f-cjk), sans-serif;
  --sy-f-heading: "Inter", var(--sy-f-sys), var(--sy-f-cjk), sans-serif;
}
</style>
    <meta property="og:type" content="website"/><meta property="og:title" content="Topology"/>
<meta name="twitter:card" content="summary"/>
  </head>
<body><div class="sy-head">
  <div class="sy-head-blur"></div>
  <div class="sy-head-inner sy-container mx-auto">
    <a class="sy-head-brand" href="index.html">
      
      
      <strong>Topology</strong>
    </a>
    <div class="sy-head-nav" id="HeadNav">
      <nav class="sy-head-links"></nav>
      <div class="sy-head-extra flex items-center print:hidden"><form class="searchbox flex items-center" action="search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <kbd>/</kbd>
</form><div class="sy-head-socials"></div></div>
    </div>
    <div class="sy-head-actions flex items-center shrink-0 print:hidden"><button class="js-theme theme-switch flex items-center"
data-aria-auto="Switch to light color mode"
data-aria-light="Switch to dark color mode"
data-aria-dark="Switch to auto color mode">
<i class="i-lucide theme-icon"></i>
</button><button class="md:hidden flex items-center js-menu" aria-label="Menu" type="button" aria-controls="HeadNav" aria-expanded="false">
        <div class="hamburger">
          <span class="hamburger_1"></span>
          <span class="hamburger_2 -translate-x-2"></span>
          <span class="hamburger_3 -translate-x-1"></span>
        </div>
      </button>
    </div>
  </div>
</div>
<div class="sy-page sy-container flex mx-auto">
  <aside id="lside" class="sy-lside md:w-72 md:shrink-0 print:hidden">
    <div class="sy-lside-inner md:sticky">
      <div class="sy-scrollbar p-6">
        <div class="globaltoc" data-expand-depth="0"><p class="caption" role="heading" aria-level="3"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Topology</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Functions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="known_topologies.html">Known Topologies Module</a></li>
</ul>

        </div>
      </div></div>
  </aside>
  <div class="lside-overlay js-menu" role="button" aria-label="Close left sidebar" aria-controls="lside" aria-expanded="false"></div>
  <aside id="rside" class="sy-rside pb-3 w-64 shrink-0 order-last">
    <button class="rside-close js-menu xl:hidden" aria-label="Close Table of Contents" type="button" aria-controls="rside" aria-expanded="false">
      <i class="i-lucide close"></i>
    </button>
    <div class="sy-scrollbar sy-rside-inner px-6 xl:top-16 xl:sticky xl:pl-0 pt-6 pb-4"><div class="localtoc"><h3>On this page</h3><ul>
<li><a class="reference internal" href="#finite_topology.topology.Topology"><code class="docutils literal notranslate"><span class="pre">Topology</span></code></a><ul>
<li><a class="reference internal" href="#finite_topology.topology.Topology.add_set"><code class="docutils literal notranslate">add_set()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.create_alexandrov_topology"><code class="docutils literal notranslate">create_alexandrov_topology()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.find_dense_subset"><code class="docutils literal notranslate">find_dense_subset()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.get_basis"><code class="docutils literal notranslate">get_basis()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.get_boundary"><code class="docutils literal notranslate">get_boundary()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.get_closure"><code class="docutils literal notranslate">get_closure()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.get_exterior"><code class="docutils literal notranslate">get_exterior()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.get_interior"><code class="docutils literal notranslate">get_interior()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.get_ordered_subsets"><code class="docutils literal notranslate">get_ordered_subsets()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.identify_topology"><code class="docutils literal notranslate">identify_topology()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.is_T0"><code class="docutils literal notranslate">is_T0()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.is_T1"><code class="docutils literal notranslate">is_T1()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.is_compact"><code class="docutils literal notranslate">is_compact()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.is_connected"><code class="docutils literal notranslate">is_connected()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.is_discrete"><code class="docutils literal notranslate">is_discrete()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.is_hausdorff"><code class="docutils literal notranslate">is_hausdorff()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.is_separable"><code class="docutils literal notranslate">is_separable()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.is_structurally_equal"><code class="docutils literal notranslate">is_structurally_equal()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.is_topology"><code class="docutils literal notranslate">is_topology()</span></code></a></li>
<li><a class="reference internal" href="#finite_topology.topology.Topology.known_topologies"><code class="docutils literal notranslate">known_topologies</span></code></a></li>
</ul>
</li>
</ul>
</div><div id="ethical-ad-placement" data-ea-publisher="readthedocs"></div></div>
  </aside>
  <div class="rside-overlay js-menu" role="button" aria-label="Close Table of Contents" aria-controls="rside" aria-expanded="false"></div>
  <main class="sy-main w-full max-sm:max-w-full print:pt-6"><div class="sy-breadcrumbs" role="navigation">
  <div class="sy-breadcrumbs-inner flex items-center">
    <div class="md:hidden mr-3">
      <button class="js-menu" aria-label="Menu" type="button" aria-controls="lside" aria-expanded="false">
        <i class="i-lucide menu"></i>
      </button>
    </div>
    <ol class="flex-1" itemscope itemtype="https://schema.org/BreadcrumbList"><li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
        <a itemprop="item" href="index.html"><span itemprop="name">Topology</span></a>
        <meta itemprop="position" content="1" />
      </li></ol>
    <div class="xl:hidden ml-1">
      <button class="js-menu" aria-label="Show table of contents" type="button" aria-controls="rside"
        aria-expanded="false">
        <i class="i-lucide outdent"></i>
      </button>
    </div>
  </div>
</div><div class="flex flex-col break-words justify-between">
      <div class="min-w-0 max-w-6xl px-6 pb-6 pt-8 xl:px-12">
        <article class="yue" role="main">
          <section id="topology">
<h1>Topology<a class="headerlink" href="#topology" title="Link to this heading">¶</a></h1>
<p><strong>Formal Definition</strong></p>
<p>A <strong>topology</strong> on a set \(X\) is a collection \(\tau\) of subsets of \(X\) such that:</p>
<ul class="simple">
<li><p>The empty set and \(X\) itself are in \(\tau\).</p></li>
<li><p>\(\tau\) is closed under arbitrary unions.</p></li>
<li><p>\(\tau\) is closed under finite intersections.</p></li>
</ul>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\text{A topology } \tau \text{ on a set } X \text{ satisfies:} \\
\emptyset, X \in \tau, \\
\forall \{ U_i \}_{i \in I} \subseteq \tau, \quad \bigcup_{i \in I} U_i \in \tau, \\
\forall U_1, U_2, \dots, U_n \in \tau, \quad \bigcap_{j=1}^n U_j \in \tau\end{split}\]</div>
</div>
<p>This class allows working with finite topological spaces, defined by providing a space and a collection of subsets.</p>
<dl class="py class" id="module-finite_topology.topology">
<dt class="sig sig-object py" id="finite_topology.topology.Topology">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">finite_topology.topology.</span></span><span class="sig-name descname"><span class="pre">Topology</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">space</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collection_of_subsets</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#finite_topology.topology.Topology" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a topology on a finite set.</p>
<p>Class Attributes:
- known_topologies (dict): Stores known topologies to facilitate identification.</p>
<p>Instance Attributes:
- space (set): The space on which the topology is defined.
- collection_of_subsets (list): Collection of subsets that form the topology.</p>
<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.add_set">
<span class="sig-name descname"><span class="pre">add_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_set</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.add_set" title="Link to this definition">¶</a></dt>
<dd><p>Adds a new set to the collection of subsets.</p>
<p>Parameters:
new_set (iterable): The new set to be added to the collection.</p>
<p>Returns:
bool: True if the new set is added successfully and the collection remains a topology, False otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.create_alexandrov_topology">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_alexandrov_topology</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">space</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_relation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relation_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'function'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#finite_topology.topology.Topology.create_alexandrov_topology" title="Link to this definition">¶</a></dt>
<dd><p>Creates the Alexandrov topology on the given space based on an order relation.</p>
<p>The <strong>Alexandrov topology</strong> is a topology where every intersection of open sets is also open. It is commonly used in domain theory and theoretical computer science.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>space</strong> (<em>set</em>) – The set on which the topology is defined.</p></li>
<li><p><strong>order_relation</strong> (<em>function</em><em> or </em><em>dict</em>) – <ul>
<li><p>If <cite>relation_type</cite> is ‘function’: A function that takes two elements (x, y) and returns True if (x leq y).</p></li>
<li><p>If <cite>relation_type</cite> is ‘dict’: A dictionary where (   ext{order_relation}[x]) is a set of elements greater than or equal to (x).</p></li>
</ul>
</p></li>
<li><p><strong>relation_type</strong> (<em>str</em>) – Specifies the type of <cite>order_relation</cite> (‘function’ or ‘dict’).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the Topology class representing the Alexandrov topology.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#finite_topology.topology.Topology" title="finite_topology.topology.Topology">Topology</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>If the space is ({a, b, c}) and the order relation is given by (a leq b) and (b leq c), the Alexandrov topology will include sets that respect this order relation.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\forall x, y \in X, \quad U \cap V \in \tau \quad \text{for all } U, V \in \tau\]</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.find_dense_subset">
<span class="sig-name descname"><span class="pre">find_dense_subset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.find_dense_subset" title="Link to this definition">¶</a></dt>
<dd><p>Finds and returns a dense subset of the topological space.</p>
<p>A <strong>dense subset</strong> of a topological space ((X,         au)) is a subset (A subseteq X) such that the closure of (A) is equal to (X). In other words, (A) is dense if every point in (X) is either in (A) or is a limit point of (A).</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{A set } A \text{ is dense in } X \text{ if } \overline{A} = X\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A dense subset if it exists, otherwise an empty set.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.get_basis">
<span class="sig-name descname"><span class="pre">get_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.get_basis" title="Link to this definition">¶</a></dt>
<dd><p>Computes and returns a basis for the topology.</p>
<p>A <strong>basis</strong> for a topology (tau) on a set (X) is a collection of open sets (mathcal{B}) such that every open set in (tau) can be written as a union of sets in (mathcal{B}).</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\forall U \in \tau, \quad \exists \{ B_i \}_{i \in I} \subseteq \mathcal{B}, \quad U = \bigcup_{i \in I} B_i\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of sets representing the basis of the topology.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[set]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.get_boundary">
<span class="sig-name descname"><span class="pre">get_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.get_boundary" title="Link to this definition">¶</a></dt>
<dd><p>Obtains the boundary of a given set in the topological space.</p>
<p>The <strong>boundary</strong> of a set (A) in a topological space ((X,    au)) is defined as the difference between the closure and the interior of (A). Formally:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\partial A = \overline{A} \setminus \text{Interior}(A)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>subset</strong> (<em>set</em>) – The set for which the boundary is to be obtained.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The boundary of the set.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.get_closure">
<span class="sig-name descname"><span class="pre">get_closure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.get_closure" title="Link to this definition">¶</a></dt>
<dd><p>Obtains the closure of a given set in the topological space.</p>
<p>The <strong>closure</strong> of a set (A) in a topological space ((X, tau)) is the smallest closed set that contains (A). Formally:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{closure}(A) = \bigcap \{ F \in \text{Closed sets of } X : A \subseteq F \}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The closure of the given set.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.get_exterior">
<span class="sig-name descname"><span class="pre">get_exterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.get_exterior" title="Link to this definition">¶</a></dt>
<dd><p>Obtains the exterior of a given set in the topological space.</p>
<p>The <strong>exterior</strong> of a set (A) in a topological space ((X, tau)) is defined as the interior of its complement.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{Exterior}(A) = \text{Interior}(X \setminus A)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>subset</strong> (<em>set</em>) – The set for which the exterior is to be obtained.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The exterior of the set.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.get_interior">
<span class="sig-name descname"><span class="pre">get_interior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.get_interior" title="Link to this definition">¶</a></dt>
<dd><p>Obtains the interior of a given set in the topological space.</p>
<p>The <strong>interior</strong> of a set (A) in a topological space ((X,    au)) is the largest open set contained within (A). Formally:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{Interior}(A) = \bigcup \{ U \in \tau : U \subseteq A \}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>subset</strong> (<em>set</em>) – The set for which the interior is to be obtained.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interior of the set.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.get_ordered_subsets">
<span class="sig-name descname"><span class="pre">get_ordered_subsets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.get_ordered_subsets" title="Link to this definition">¶</a></dt>
<dd><p>Returns the collection of subsets aesthetically ordered.</p>
<p>Returns:
List[Set]: List of subsets ordered by the specified criterion.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.identify_topology">
<span class="sig-name descname"><span class="pre">identify_topology</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">known_topologies</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.identify_topology" title="Link to this definition">¶</a></dt>
<dd><p>Identifies the topology by comparing it to a list of known topologies.</p>
<p>Parameters:
known_topologies (dict): A dictionary with names as keys and Topology objects as values.</p>
<p>Returns:
list: Names of known topologies that are homeomorphic to this topology.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.is_T0">
<span class="sig-name descname"><span class="pre">is_T0</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.is_T0" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the topological space is T0.</p>
<p>In a T0 space (Kolmogorov space), for every pair of distinct points, there exists an open set containing one of the points but not the other.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\forall x, y \in X, \; x \neq y \implies \exists U \in \tau, \; (x \in U \wedge y \notin U) \text{ or } (y \in U \wedge x \notin U)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the space is T0, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.is_T1">
<span class="sig-name descname"><span class="pre">is_T1</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.is_T1" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the topological space is T1.</p>
<p>A topological space ((X,       au)) is <strong>T1</strong> if, for every pair of distinct points, each has a neighborhood that does not contain the other.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\forall x, y \in X, \; x \neq y \implies \exists U, V \in \tau, \; (x \in U \wedge y \notin U) \wedge (y \in V \wedge x \notin V)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the space is T1, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.is_compact">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_compact</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.is_compact" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the topological space is compact.</p>
<p>A topological space is <strong>compact</strong> if every open cover has a finite subcover.
Formally, given an open cover of the space, which is a collection of open sets whose union contains the entire space,
there exists a finite subcollection that also covers the entire space.</p>
<p>Definitions:</p>
<ul>
<li><p><strong>Open Cover</strong>: An open cover of a set ( X ) in a topological space ((X, tau)) is a collection of open sets ({U_i}_{i in I})
such that the union of all (U_i) contains the set (X):</p>
<p>[
X subseteq bigcup_{i in I} U_i
]</p>
</li>
<li><p><strong>Subcover</strong>: A subcover is a subcollection of the open cover that still covers the set ( X ). In other words, if ({U_i}_{i in I})
is an open cover of (X), a <strong>subcover</strong> is a subcollection ({U_j}_{j in J}), where (J subseteq I), such that:</p>
<p>[
X subseteq bigcup_{j in J} U_j
]</p>
</li>
</ul>
<p>In the case of finite spaces, every topological space is compact because we can always trivially find a finite subcover for any given open cover.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the space is compact, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.is_connected">
<span class="sig-name descname"><span class="pre">is_connected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.is_connected" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the topological space is connected.</p>
<p>A topological space ((X, tau)) is <strong>connected</strong> if it cannot be represented as the union of two disjoint non-empty open sets.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{A space is connected if } \nexists U, V \in \tau, \quad U \cap V = \emptyset, \; U \cup V = X, \; U \neq \emptyset, \; V \neq \emptyset\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the space is connected, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.is_discrete">
<span class="sig-name descname"><span class="pre">is_discrete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.is_discrete" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the topology is discrete.</p>
<p>A <strong>discrete topology</strong> on a set (X) is the topology in which every subset of (X) is open. This means the topology (tau) is equal to the power set of (X).</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\tau = \mathcal{P}(X)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the topology is discrete, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.is_hausdorff">
<span class="sig-name descname"><span class="pre">is_hausdorff</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.is_hausdorff" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the topological space is Hausdorff (T2).</p>
<p>A topological space ((X, tau)) is <strong>Hausdorff</strong> if, for any two distinct points, there exist disjoint open sets containing each of the points.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\forall x, y \in X, \; x \neq y \implies \exists U, V \in \tau, \; x \in U, \; y \in V, \; U \cap V = \emptyset\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the space is Hausdorff, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.is_separable">
<span class="sig-name descname"><span class="pre">is_separable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.is_separable" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the topological space is separable.</p>
<p>A <strong>separable space</strong> is one that contains a countable, dense subset.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In finite topological spaces, any non-empty subset can be considered dense if its closure is the entire space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the space is separable, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.is_structurally_equal">
<span class="sig-name descname"><span class="pre">is_structurally_equal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#finite_topology.topology.Topology" title="finite_topology.topology.Topology"><span class="pre">Topology</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.is_structurally_equal" title="Link to this definition">¶</a></dt>
<dd><p>Checks if two topologies have the same structure, regardless of the elements.</p>
<p>Parameters:
other (Topology): Another topology to compare.</p>
<p>Returns:
bool: True if the topologies have the same structure, False otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.is_topology">
<span class="sig-name descname"><span class="pre">is_topology</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#finite_topology.topology.Topology.is_topology" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the collection of subsets forms a topology on the given space.</p>
<p>Returns:
bool: True if the collection is a topology, False otherwise.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="finite_topology.topology.Topology.known_topologies">
<span class="sig-name descname"><span class="pre">known_topologies</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{}</span></em><a class="headerlink" href="#finite_topology.topology.Topology.known_topologies" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>

        </article><button class="back-to-top" type="button">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
  </svg>
  <span>Back to top</span>
</button><div class="navigation flex print:hidden"><div class="navigation-prev">
    <a href="index.html">
      <i class="i-lucide chevron-left"></i>
      <div class="page-info">
        <span>Previous</span><div class="title">Home</div></div>
    </a>
  </div><div class="navigation-next">
    <a href="functions.html">
      <div class="page-info">
        <span>Next</span>
        <div class="title">Functions Module</div>
      </div>
      <i class="i-lucide chevron-right"></i>
    </a>
  </div></div></div>
    </div>
  </main>
</div>
<footer class="sy-foot">
  <div class="sy-foot-inner sy-container mx-auto">
    <div class="sy-foot-reserved md:flex justify-between items-center">
      <div class="sy-foot-copyright"><p>2024, Nand0san</p>
  
  <p>
    Made with
    
    <a href="https://www.sphinx-doc.org/">Sphinx</a> and
    
    <a href="https://shibuya.lepture.com">Shibuya theme</a>.
  </p>
</div>
      <div class="sy-foot-socials"></div>
    </div>
  </div>
</footer>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/shibuya.js?v=c5fc9e80"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></body>
</html>